<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="trabalho-1---introdu%C3%A7%C3%A3o-ao-processamento-de-imagens-digitais">Trabalho 1 - Introdução ao Processamento de Imagens Digitais</h1>
<h3 id="nome">Nome</h3>
<p>Victor Palmerini</p>
<h3 id="ra">RA</h3>
<p>178061</p>
<h3 id="data">Data</h3>
<p>01/04/2020</p>
<h2 id="introdu%C3%A7%C3%A3o">Introdução</h2>
<p>Este é o Trabalho 1 da disciplina <em><strong>MC920</strong> - Introdução ao Processamento de Imagens Digitais</em> da <strong>Unicamp</strong> - Universidade Estadual de Campinas.</p>
<p>O principal objetivo deste trabalho é desenvolver uma boa noção sobre alguns dos mais básicos processamentos de imagens digitais como: manipulação da resolução, quantização e escala de cinza.</p>
<p>O trabalho requer por parte do aluno um conhecimento básico da linguagem de programação <code>python</code> e bibliotecas que facilitem a manipulação das imagens digitais bem como seus processamentos. No caso deste trabalho, foram usados os pacotes <code>numpy</code>, <code>pillow</code> e <code>jupyter notebook</code>. Estes pacotes serão mencionados com mais detalhes no decorrer do relatório.</p>
<h2 id="desenvolvimento">Desenvolvimento</h2>
<h3 id="estrutura-do-projeto">Estrutura do Projeto</h3>
<ol>
<li>
<p><code>/notebooks</code> - é a pasta que contém os notebooks com os algoritmos para serem executados pelo <code>jupyter notebook</code></p>
</li>
<li>
<p><code>requirements.txt</code> - é um arquivo texto que contém as dependências para executar a aplicação (foi gerado pelo pacote <code>pip</code> através do comando <code>pip freeze &gt; requirements.txt</code>)</p>
</li>
<li>
<p><code>Pipfile</code> e <code>Pipfile.lock</code> - são os arquivos relacionados ao <code>ambiente virtual</code> aonde as dependências são instaladas e executadas. Isso permite que as dependências sejam instaladas apenas no ambiente virtual e não no ambiente local.</p>
</li>
<li>
<p><code>/images</code> - pasta com algumas imagens usadas como entrada para execução dos notebooks</p>
</li>
</ol>
<h3 id="rodando-localmente">Rodando Localmente</h3>
<h4 id="depend%C3%AAncias">Dependências</h4>
<p>Para executar os notebooks é necessário instalar as seguintes dependências:</p>
<ol>
<li>
<p><code>Python 3</code> - neste projeto foi usada a versão <code>3.7.3</code>. Qualquer versão do <code>python</code> a partir da <code>3</code> é suficiente.</p>
</li>
<li>
<p><code>Pipenv</code> - gerenciador de ambientes virtuais. É equivalente ao <code>virtualenv</code>.</p>
</li>
</ol>
<h4 id="inicializa%C3%A7%C3%A3o-do-ambiente">Inicialização do Ambiente</h4>
<p>Na pasta root do projeto, execute os seguintes comandos em uma <code>shell</code>:</p>
<ol>
<li>
<p><code>pipenv shell</code> - para iniciar um ambiente virtual localmente</p>
</li>
<li>
<p><code>pipenv install -r requirements.txt</code> - instala no ambiente virtual todas as dependências listadas no arquivo <code>requirements.txt</code></p>
</li>
</ol>
<h4 id="executando-os-notebooks">Executando os notebooks</h4>
<p>Para executar os notebooks, há 2 caminhos:</p>
<ol>
<li>
<p>Executar <code>jupyter notebook</code> em uma <code>shell</code> para subir um servidor do <code>jupyterlab</code> que vai abrir automaticamente o navegador padrão com o ambiente <code>jupyter</code> e as pastas e arquivos do projeto.</p>
</li>
<li>
<p>Caso o projeto tenha sido aberto no <code>Visual Studio Code</code>, é possível subir o servidor do <code>jupyterlab</code> executando a task <code>Start Notebook</code>. Uma outra opção é instalar a extensão <code>VS Code Jupyter Notebook</code>, que permite executar os notebooks no próprio <code>VS Code</code>.</p>
</li>
</ol>
<h4 id="entradas">Entradas</h4>
<p>As entradas dos notebooks serão o <code>path</code> da imagem de entrada, o <code>path</code> da <strong>pasta</strong> de saída e algum ou alguns outros parâmetros necessários para a execução do processamento. As imagens de entrada utilizadas são <em>monocromáticas</em>, no formato <code>.png</code> e com 256 níveis de intensidade. Como foi falado, na pasta <code>/images</code> há algumas imagens que podem ser usadas como entrada.</p>
<h4 id="sa%C3%ADdas">Saídas</h4>
<p>As saídas também serão imagens <em>monocromáticas</em>, no formato <code>.png</code> e com um número de níveis de intensidade que pode ser diferente de 256 dependendo do processamento aplicado. Alguns notebooks irão gerar mais de uma imagem como saída. Isto será especificado no momento de execução do notebook.</p>
<h3 id="implementa%C3%A7%C3%A3o-dos-processamentos">Implementação dos Processamentos</h3>
<h4 id="diminui%C3%A7%C3%A3o-da-resolu%C3%A7%C3%A3o">Diminuição da Resolução</h4>
<p>Este processamento, implementado no notebook <code>resolution.ipynb</code>, consiste em diminuir a densidade de pixels numa imagem digital. Isto pode ser feito diminuindo o número de pixels de uma imagem mas mantendo as suas dimensões, dessa forma o número de pixels por unidade de espaço diminui.</p>
<p>Em termos de implementação, este processamento consiste em transformar cada bloco de 4 pixels da matriz que representa a imagem em blocos de 1 pixel. O método mais comum consiste em obter a média aritmética dos 4 valores de intensidade de cada pixel e atribuir pro pixel resultante. Após isso, a matriz resultante terá a metade da altura e a metade da largura, portanto terá 4x menos elementos. Como o tamanho da imagem deve ser preservado, basta redimensionar a matriz para o tamanho original.</p>
<p>Explicando o código com o algoritmo citado em mais detalhes:</p>
<ol>
<li>
<p>Primeiro obtém-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada (ex: <code>../images/city.png</code>)</li>
<li><code>path</code> da pasta de saída (este notebook pode gerar várias imagens de saída) - (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>nº de imagens de saída (cada imagem de saída terá a metade da resolução em relação à imagem anterior)</li>
</ul>
</li>
<li>
<p>Supondo que se quer <code>k</code> imagens de saída, para cada iteração a imagem de entrada é redimensionada para metade do tamanho (altura e largura) da imagem anterior. Feito isso, a imagem é redimensionada novamente para o tamanho original. Para este processamento utilizou-se a função <code>resize()</code> da biblioteca <code>Pillow</code> com o parâmetro <code>resample=Image.BOX</code>. Este parâmetro considera os pixels da imagem original com pesos iguais para gerar o pixel resultante da imagem de saída.</p>
</li>
<li>
<p>Salva-se cada imagem de saída no formato <code>.png</code> e com o mesmo tamanho da imagem original na pasta de saída especificada. Os nomes das imagens seguirão o padrão <code>reduced{k}.png</code>, onde <code>k²</code> é o número de pixels que a imagem possui depois da transformação.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/resolution</code></li>
<li>Nº de Saídas (k): <code>6</code></li>
</ul>
<p><em>Imagem Original <strong>512x512</strong> Pixels</em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original 512x512 Pixels"></p>
<p><em>Imagem <strong>256x256</strong> Pixels</em></p>
<p><img src="./outputs/reduce_resolution/reduced256.png" alt="imagem 256x256 pixels" title="Imagem 256x256 Pixels"></p>
<p><em>Imagem <strong>128x128</strong> Pixels</em></p>
<p><img src="./outputs/reduce_resolution/reduced128.png" alt="imagem 128x128 pixels" title="Imagem 128x128 Pixels"></p>
<p><em>Imagem <strong>64x64</strong> Pixels</em></p>
<p><img src="./outputs/reduce_resolution/reduced64.png" alt="imagem 64x64 pixels" title="Imagem 64x64 Pixels"></p>
<p><em>Imagem <strong>32x32</strong> Pixels</em></p>
<p><img src="./outputs/reduce_resolution/reduced32.png" alt="imagem 32x32 pixels" title="Imagem 32x32 Pixels"></p>
<p><em>Imagem <strong>16x16</strong> Pixels</em></p>
<p><img src="./outputs/reduce_resolution/reduced16.png" alt="imagem 16x16 pixels" title="Imagem 16x16 Pixels"></p>
<p><em>Imagem <strong>8x8</strong> Pixels</em></p>
<p><img src="./outputs/reduce_resolution/reduced8.png" alt="imagem 8x8 pixels" title="Imagem 8x8 Pixels"></p>
<h4 id="diminui%C3%A7%C3%A3o-da-quantiza%C3%A7%C3%A3o">Diminuição da Quantização</h4>
<p>A quantização de uma imagem está relacionada aos níveis de intensidade da imagem digital. Se uma imagem possui 256 níveis de intensidade então ela possui 8 planos de bit, pois os valores de intensidade podem ser representados em 8 bits. Conforme se diminui o número de bits pra representação da intensidade, o número de valores possíveis também diminiu.</p>
<p>Em termos de implementação, este processamento, implementado no notebook <code>quantize.ipynb</code>, consiste em diminuir o número de bits necessários pra representar a intensidade de cinza da imagem monocromática. Este número é então diminuído pela metade a cada iteração ou, em outras palavras, a representação em bits é &quot;shiftada&quot; pra esquerda. Desta forma, a imagem possui cada vez menos valores possíveis para representar os níveis de cinza.</p>
<p>Explicando o código com o algoritmo citado em mais detalhes:</p>
<ol>
<li>
<p>Primeiro obtém-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada</li>
<li><code>path</code> da pasta de saída (este notebook pode gerar várias imagens de saída) - (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>nº de imagens de saída (cada imagem de saída terá a metade da resolução em relação à imagem anterior)</li>
</ul>
</li>
<li>
<p>Supondo que se quer <code>k</code> imagens de saída, para cada iteração a imagem de entrada tem o número total de possíveis níveis de cinza diminuído pela metade. Utilizou-se para esse processamento a função <code>quantize()</code> da biblioteca <code>Pillow</code>. Esta função altera então o número de níveis de cinza que a imagem pode ter, tanto aumentando quanto diminuindo este número (que é o caso deste trabalho).</p>
</li>
<li>
<p>Salva-se cada imagem de saída no formato <code>.png</code> e com o mesmo tamanho da imagem original na pasta de saída especificada. Os nomes das imagens seguirão o padrão <code>quantize{k}.png</code>, onde <code>k</code> é o número de níveis de intensidade que a imagem possui depois da transformação.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/quantize</code></li>
<li>Nº de Saídas (k): <code>8</code></li>
</ul>
<p><em>Imagem Original <strong>256</strong> Níveis</em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original 256 níveis"></p>
<p><em>Imagem <strong>128</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize128.png" alt="imagem 128 níveis" title="Imagem 128 Níveis"></p>
<p><em>Imagem <strong>64</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize64.png" alt="imagem 64 níveis" title="Imagem 64 Níveis"></p>
<p><em>Imagem <strong>32</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize32.png" alt="imagem 32 níveis" title="Imagem 32 Níveis"></p>
<p><em>Imagem <strong>16</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize16.png" alt="imagem 16 níveis" title="Imagem 16 Níveis"></p>
<p><em>Imagem <strong>8</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize8.png" alt="imagem 8 níveis" title="Imagem 8 Níveis"></p>
<p><em>Imagem <strong>4</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize4.png" alt="imagem 4 níveis" title="Imagem 4 Níveis"></p>
<p><em>Imagem <strong>2</strong> Níveis</em></p>
<p><img src="./outputs/quantize/quantize2.png" alt="imagem 2 níveis" title="Imagem 2 Níveis"></p>
<p><em>Imagem <strong>1</strong> Nível</em></p>
<p><img src="./outputs/quantize/quantize1.png" alt="imagem 1 nível" title="Imagem 1 Nível"></p>
<h4 id="transforma%C3%A7%C3%B5es-na-escala-de-cinza">Transformações na Escala de Cinza</h4>
<p>É possível aplicar filtros em imagens digitais a partir de transformações lineares nos valores que representam a intensidade de cinza da imagem. Estas transformações podem deixar a imagem mais clara, mais escura ou com mais ou menos contraste, por exemplo.</p>
<h5 id="1-transforma%C3%A7%C3%A3o-logar%C3%ADtmica">1. Transformação Logarítmica</h5>
<p>A transformação logarítmica tem por objetivo deixar a imagem mais clara, realçando os níveis de cinza que possuem maior intensidade.</p>
<p>Sua implementação (<code>/gray_scale/log.ipynb</code>) é feita aplicando-se a seguinte função <code>g = c * log(f + 1)</code> para todos os pixels da imagem original.</p>
<ul>
<li><code>f</code> é o valor da intensidade de cinza</li>
<li><code>c</code> é uma constante arbitrária</li>
</ul>
<p>O notebook consiste em:</p>
<ol>
<li>
<p>Obter-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada</li>
<li><code>path</code> da pasta de saída (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>constante <code>c</code> usada para aumentar ou diminuir o efeito da transformação</li>
</ul>
</li>
<li>
<p>Aplica-se a transformação através da função <code>g</code> em todos os pixels da imagem de entrada.</p>
</li>
<li>
<p>Gera-se a imagem de saída com a transformação aplicada e esta é salva na pasta de saída especificada e com a imagem nomeada como <code>log.png</code>.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/log</code></li>
<li>Constante <code>c</code>: <code>2</code></li>
</ul>
<p><em>Imagem Original <strong>função f</strong></em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original Função f"></p>
<p><em>Imagem <strong>função g(f)</strong></em></p>
<p><img src="./outputs/log/log.png" alt="imagem transformação log" title="Imagem Transformação Log"></p>
<h5 id="2-transforma%C3%A7%C3%A3o-exponencial">2. Transformação Exponencial</h5>
<p>A transformação exponencial tem por objetivo deixar a imagem mais escura, realçando os níveis de cinza que possuem menor intensidade.</p>
<p>Sua implementação (<code>/gray_scale/exp.ipynb</code>) é feita aplicando-se a seguinte função <code>g = c * e^f</code> para todos os pixels da imagem original.</p>
<ul>
<li><code>f</code> é o valor da intensidade de cinza</li>
<li><code>c</code> é uma constante arbitrária</li>
</ul>
<p>O notebook consiste em:</p>
<ol>
<li>
<p>Obter-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada</li>
<li><code>path</code> da pasta de saída (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>constante <code>c</code> usada para aumentar ou diminuir o efeito da transformação</li>
</ul>
</li>
<li>
<p>Aplica-se a transformação através da função <code>g</code> em todos os pixels da imagem de entrada.</p>
</li>
<li>
<p>Gera-se a imagem de saída com a transformação aplicada e esta é salva na pasta de saída especificada e com a imagem nomeada como <code>exp.png</code>.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/exp</code></li>
<li>Constante <code>c</code>: <code>2</code></li>
</ul>
<p><em>Imagem Original <strong>função f</strong></em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original Função f"></p>
<p><em>Imagem <strong>função g(f)</strong></em></p>
<p><img src="./outputs/exp/exp.png" alt="imagem transformação exponencial" title="Imagem Transformação Exponencial"></p>
<h5 id="3-transforma%C3%A7%C3%A3o-quadr%C3%A1tica">3. Transformação Quadrática</h5>
<p>A transformação quadrática tem por objetivo deixar a imagem mais escura (mais ainda que a exponencial), realçando os níveis de cinza que possuem menor intensidade.</p>
<p>Sua implementação (<code>/gray_scale/quadratic.ipynb</code>) é feita aplicando-se a seguinte função <code>g = c * f^2</code> para todos os pixels da imagem original.</p>
<ul>
<li><code>f</code> é o valor da intensidade de cinza</li>
<li><code>c</code> é uma constante arbitrária</li>
</ul>
<p>O notebook consiste em:</p>
<ol>
<li>
<p>Obter-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada</li>
<li><code>path</code> da pasta de saída (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>constante <code>c</code> usada para aumentar ou diminuir o efeito da transformação</li>
</ul>
</li>
<li>
<p>Aplica-se a transformação através da função <code>g</code> em todos os pixels da imagem de entrada.</p>
</li>
<li>
<p>Gera-se a imagem de saída com a transformação aplicada e esta é salva na pasta de saída especificada e com a imagem nomeada como <code>quadratic.png</code>.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/quadratic</code></li>
<li>Constante <code>c</code>: <code>2</code></li>
</ul>
<p><em>Imagem Original <strong>função f</strong></em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original Função f"></p>
<p><em>Imagem <strong>função g(f)</strong></em></p>
<p><img src="./outputs/quadratic/quadratic.png" alt="imagem transformação quadrática" title="Imagem Transformação Quadrática"></p>
<h5 id="4-transforma%C3%A7%C3%A3o-raiz-quadrada">4. Transformação Raiz Quadrada</h5>
<p>A transformação raiz quadrada tem por objetivo deixar a imagem mais clara (menos que a logarítmica), realçando os níveis de cinza que possuem maior intensidade.</p>
<p>Sua implementação (<code>/gray_scale/square_root.ipynb</code>) é feita aplicando-se a seguinte função <code>g = c * sqrt(f)</code> para todos os pixels da imagem original.</p>
<ul>
<li><code>f</code> é o valor da intensidade de cinza</li>
<li><code>c</code> é uma constante arbitrária</li>
</ul>
<p>O notebook consiste em:</p>
<ol>
<li>
<p>Obter-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada</li>
<li><code>path</code> da pasta de saída (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>constante <code>c</code> usada para aumentar ou diminuir o efeito da transformação</li>
</ul>
</li>
<li>
<p>Aplica-se a transformação através da função <code>g</code> em todos os pixels da imagem de entrada.</p>
</li>
<li>
<p>Gera-se a imagem de saída com a transformação aplicada e esta é salva na pasta de saída especificada e com a imagem nomeada como <code>square_root.png</code>.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/square_root</code></li>
<li>Constante <code>c</code>: <code>2</code></li>
</ul>
<p><em>Imagem Original <strong>função f</strong></em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original Função f"></p>
<p><em>Imagem <strong>função g(f)</strong></em></p>
<p><img src="./outputs/square_root/square_root.png" alt="imagem transformação raiz quadrada" title="Imagem Transformação Raiz Quadrada"></p>
<h5 id="5-transforma%C3%A7%C3%A3o-do-contraste">5. Transformação do Contraste</h5>
<p>A transformação de contraste tem por objetivo manipular o contraste da imagem, isto é, aumentar ou diminuir a diferença entre os valores de intensidade de cinza da imagem.</p>
<p>Sua implementação (<code>/gray_scale/contrast.ipynb</code>) é feita aplicando-se a seguinte função para todos os pixels da imagem original:</p>
<pre class="hljs"><code><div>g = (alpha * f), se 0 &lt;= f &lt;= a
g = (betha * (f - a)) + (alpha * a), se a &lt; f &lt;= b
g = (gamma * (f - b)) + (betha * (b - a) + alpha * a), se b &lt; f &lt;= L
</div></code></pre>
<p>Onde:</p>
<ul>
<li><code>f</code> é o valor da intensidade de cinza</li>
<li><code>L</code> é o número total de níveis possíveis (em geral 256)</li>
<li><code>a</code> e <code>b</code> são valores arbitrários entre 0 e <code>L</code></li>
<li><code>alpha</code>, <code>betha</code> e <code>gamma</code> são constante arbitrárias usadas pra aumentar ou diminuir o efeito da transformação</li>
</ul>
<p>O notebook consiste em:</p>
<ol>
<li>
<p>Obter-se as entradas:</p>
<ul>
<li><code>path</code> da imagem de entrada</li>
<li><code>path</code> da pasta de saída (ex: <code>../outputs</code>, a pasta <code>/outputs</code> deve existir)</li>
<li>constante <code>L</code> que representa o número de níveis possíveis na imagem</li>
<li>constantes <code>a</code> e <code>b</code> usados para definir os intervalos em que será aplicada a transformação com diferentes efeitos pra cada intervalo</li>
<li>constantes <code>alpha</code>, <code>betha</code> e <code>gamma</code> usadas para aumentar ou diminuir o efeito da transformação pra cada intervalo</li>
</ul>
</li>
<li>
<p>Aplica-se a transformação através da função <code>g</code> em todos os pixels da imagem de entrada.</p>
</li>
<li>
<p>Gera-se a imagem de saída com a transformação aplicada e esta é salva na pasta de saída especificada e com a imagem nomeada como <code>contrast.png</code>.</p>
</li>
</ol>
<p>Exemplo:</p>
<ul>
<li>Imagem de Entrada: <code>../images/baboon.png</code></li>
<li>Path de Saída: <code>../outputs/contrast</code></li>
<li>Parâmetros:
<ul>
<li><code>c</code>: <code>2</code></li>
<li><code>L</code>: <code>256</code></li>
<li><code>a</code>: <code>30</code></li>
<li><code>b</code>: <code>230</code></li>
<li><code>alpha</code>: <code>0.2</code></li>
<li><code>betha</code>: <code>0</code></li>
<li><code>gamma</code>: <code>0.5</code></li>
</ul>
</li>
</ul>
<p><em>Imagem Original <strong>função f</strong></em></p>
<p><img src="./images/baboon.png" alt="imagem original" title="Imagem Original Função f"></p>
<p><em>Imagem <strong>função g(f)</strong></em></p>
<p><img src="./outputs/contrast/contrast.png" alt="imagem transformação raiz quadrada" title="Imagem Transformação de Contraste"></p>
<h2 id="an%C3%A1lise">Análise</h2>
<h4 id="diminui%C3%A7%C3%A3o-da-resolu%C3%A7%C3%A3o">Diminuição da Resolução</h4>
<p>Analisando o comportamento da transformação de diminuir a resolução, percebe-se que a cada iteração, isto é, a cada diminuição pela metade do número de pixels, a imagem fica com uma definição cada vez menor.</p>
<p>Conclui-se então que a resolução de uma imagem digital está diretamente relacionada à quantidade de pixels que ela possui dado um espaço (altura x largura) constante. Além disso o tamanho da imagem, em bytes, também diminui, já que agora há menos informação contida na imagem. Consegue-se então diminuir consideravelmente o tamanho da imagem (em bytes) mas sem perder tanta qualidade caso se considere poucas reduções, como é exemplificado abaixo:</p>
<p><em>Imagem Original (512x512 Pixels) - <strong>100.1 kB</strong></em></p>
<p><img src="./images/seagull.png" alt="imagem original" title="Imagem Original - 100.1 kB"></p>
<p><em>Imagem 256x256 Pixels - <strong>47.2 kB</strong></em></p>
<p><img src="./outputs_aux/reduced_resolution/reduced256.png" alt="imagem 256 pixels" title="Imagem 256 Pixels - 47.2 kB"></p>
<h4 id="quantiza%C3%A7%C3%A3o">Quantização</h4>
<p>Analisando o comportamento da transformação de quantização, percebe-se que a cada iteração, isto é, a cada diminuição pela metade do número de bits pra representar a intensidade de cinza, a imagem tem menos cores. Isso fica bem nítido nos casos em que a imagem tem 2 bits (4 cores) ou menos pra representar as intensidades.</p>
<p>Comparando-se os tamanhos (em bytes) dessas imagens, percebe-se que a imagem representada com 4 bits, por exemplo, possui praticamente a metade do tamanho da imagem original (8 bits). E ainda assim possui uma qualidade muito parecida com a imagem original (considerando as características das imagens usadas como entrada para este projeto).</p>
<p>Conclui-se então que este é um bom método para diminuir o tamanho de uma imagem monocromática, por exemplo, sem que esta perca muita qualidade no processo.</p>
<p><em>Imagem Original (256 Níveis) - <strong>220.1 kB</strong></em></p>
<p><img src="./images/city.png" alt="imagem original" title="Imagem Original - 220.1 kB"></p>
<p><em>Imagem 128 Níveis - <strong>47.2 kB</strong></em></p>
<p><img src="./outputs_aux/quantize/quantize128.png" alt="imagem 128 níveis" title="Imagem 128 Níveis - 47.2 kB"></p>
<h4 id="transforma%C3%A7%C3%A3o-logar%C3%ADtmica">Transformação Logarítmica</h4>
<p>Analisando o comportamento da transformação logarítmica, percebe-se que a imagem fica mais clara com os valores adequados pra constante <code>c</code>. Atribuindo valores positivos baixos a <code>c</code>, como <code>1</code> ou <code>2</code>, não consegue-se visualizar a imagem pois os níveis de cinza ainda ficam muito baixos, já que a transformação com a função logarítmica diminui bastante esses valores.</p>
<p>Pode-se então aumentar o valor de <code>c</code> o quanto se queira pra deixar a imagem mais clara. Segue algumas imagens com diferentes valores de <code>c</code>.</p>
<p><em>Imagem Original</em></p>
<p><img src="./images/butterfly.png" alt="imagem original" title="Imagem Original"></p>
<p><em>Imagem Transformação log com <code>c = 10</code></em></p>
<p><img src="./outputs_aux/log/log1.png" alt="imagem c = 10" title="Imagem c = 10"></p>
<p><em>Imagem Transformação log com <code>c = 20</code></em></p>
<p><img src="./outputs_aux/log/log2.png" alt="imagem c = 20" title="Imagem c = 20"></p>
<p><em>Imagem Transformação log com <code>c = 30</code></em></p>
<p><img src="./outputs_aux/log/log3.png" alt="imagem c = 30" title="Imagem c = 30"></p>
<h4 id="transforma%C3%A7%C3%A3o-com-raiz-quadrada">Transformação com Raiz Quadrada</h4>
<p>Analisando o comportamento da transformação com raiz quadrada, percebe-se que a imagem fica mais clara com os valores adequados pra constante <code>c</code>. Esta transformação é parecida com a transformação logarítmica, no sentido de que aplica o mesmo efeito, porém a intensidade deste efeito é maior aqui, já que a função de raiz quadrada não diminui tanto os valores de intensidade quanto a função logarítmica.</p>
<p>Atribuindo valores positivos baixos a <code>c</code>, como <code>1</code> ou <code>2</code>, não consegue-se visualizar a imagem pois os níveis de cinza ainda ficam um pouco baixos, já que a transformação com a função de raiz quadrada diminui consideravelmente esses valores.</p>
<p>Pode-se então aumentar o valor de <code>c</code> o quanto se queira pra deixar a imagem mais clara. Segue algumas imagens com diferentes valores de <code>c</code>.</p>
<p><em>Imagem Original</em></p>
<p><img src="./images/butterfly.png" alt="imagem original" title="Imagem Original"></p>
<p><em>Imagem Transformação raiz quadrada com <code>c = 10</code></em></p>
<p><img src="./outputs_aux/square_root/square_root1.png" alt="imagem c = 10" title="Imagem c = 10"></p>
<p><em>Imagem Transformação raiz quadrada com <code>c = 20</code></em></p>
<p><img src="./outputs_aux/square_root/square_root2.png" alt="imagem c = 20" title="Imagem c = 20"></p>
<p><em>Imagem Transformação raiz quadrada com <code>c = 30</code></em></p>
<p><img src="./outputs_aux/square_root/square_root3.png" alt="imagem c = 30" title="Imagem c = 30"></p>
<h4 id="transforma%C3%A7%C3%A3o-quadr%C3%A1tica">Transformação Quadrática</h4>
<p>Analisando o comportamento da transformação quadrática, percebe-se que a imagem fica mais escura com os valores adequados pra constante <code>c</code>.</p>
<p>Atribuindo valores positivos baixos a <code>c</code>, como <code>0.1</code> ou <code>0.2</code>, não consegue-se visualizar a imagem pois os níveis de cinza ainda ficam um pouco baixos, já que a transformação com a função quadrática diminui consideravelmente esses valores. Além disso a imagem ficou com uma aparência diferente e perdeu os traços originais. A razão disso acontecer não foi descoberta com clareza.</p>
<p>Em relação aos níveis de intensidade, pode-se então aumentar o valor de <code>c</code> o quanto se queira pra deixar a imagem mais clara. Segue algumas imagens com diferentes valores de <code>c</code>.</p>
<p><em>Imagem Original</em></p>
<p><img src="./images/house.png" alt="imagem original" title="Imagem Original"></p>
<p><em>Imagem Transformação quadrática com <code>c = 0.15</code></em></p>
<p><img src="./outputs_aux/quadratic/quadratic1.png" alt="imagem c = 0.15" title="Imagem c = 0.15"></p>
<p><em>Imagem Transformação quadrática com <code>c = 0.3</code></em></p>
<p><img src="./outputs_aux/quadratic/quadratic2.png" alt="imagem c = 0.3" title="Imagem c = 0.3"></p>
<p><em>Imagem Transformação quadrática com <code>c = 0.6</code></em></p>
<p><img src="./outputs_aux/quadratic/quadratic3.png" alt="imagem c = 0.6" title="Imagem c = 0.6"></p>
<h4 id="transforma%C3%A7%C3%A3o-exponencial">Transformação Exponencial</h4>
<p>Analisando o comportamento da transformação exponencial, percebe-se que a imagem fica mais escura com os valores adequados pra constante <code>c</code>.</p>
<p>Atribuindo valores positivos baixos a <code>c</code>, como <code>0.1</code> ou <code>0.2</code>, percebe-se um escurecimento bem considerável da imagem, já que a transformação com a função exponencial aumenta muitos os valores de intensidade, porém a função é normalizada para o intervalo [0,1] pra justamente evitar essa situação.</p>
<p>Pode-se então alterar o valor de <code>c</code> o quanto se queira pra deixar a imagem mais clara (aumentando <code>c</code>) ou mais escura (diminuindo <code>c</code>). Segue algumas imagens com diferentes valores de <code>c</code>.</p>
<p>Percebe-se na última imagem que os valores muito altos, próximos do branco, ultrapassaram o valor máximo de <code>255</code> e acabaram virando valores baixos, bem próximos do preto. Por isso essa diferença em relação às outras imagens.</p>
<p><em>Imagem Original</em></p>
<p><img src="./images/house.png" alt="imagem original" title="Imagem Original"></p>
<p><em>Imagem Transformação exponencial com <code>c = 0.1</code></em></p>
<p><img src="./outputs_aux/exp/exp1.png" alt="imagem c = 0.1" title="Imagem c = 0.1"></p>
<p><em>Imagem Transformação exponencial com <code>c = 0.3</code></em></p>
<p><img src="./outputs_aux/exp/exp2.png" alt="imagem c = 0.3" title="Imagem c = 0.3"></p>
<p><em>Imagem Transformação exponencial com <code>c = 0.5</code></em></p>
<p><img src="./outputs_aux/exp/exp3.png" alt="imagem c = 0.5" title="Imagem c = 0.5"></p>
<h4 id="transforma%C3%A7%C3%A3o-do-contraste">Transformação do Contraste</h4>
<p>Analisando o comportamento da transformação de contraste, percebe-se que a imagem pode ficar com um contraste maior ou menor dependendo dos valores dos parâmetros <code>a</code>, <code>b</code>, <code>alpha</code>, <code>betha</code> e <code>gamma</code>.</p>
<p>A função de contraste se comporta de uma forma diferente em relação às outras funções deste trabalho. Isso porque ela divide o intervalo de níveis em 3 blocos e aplica um efeito de realce maior ou menor pra esses blocos de acordo com os valores dos parâmetros citados.</p>
<p>Os parâmetros <code>a</code> e <code>b</code> são os responsáveis por definir o &quot;tamanho&quot; de cada um dos 3 blocos e os parâmetros <code>alpha</code>, <code>betha</code> e <code>gamma</code> são os responsáveis por realçar mais ou menos a intensidade do 1º ([0,a]), 2º ([a,b]) e 3º ([b,255]) blocos respectivamente.</p>
<p>Nas imagens abaixo mantém-se os valores de <code>a</code> e <code>b</code> constantes em todas as imagens e com valores de forma que dividam o intervalo de intensidades em blocos de tamanho similares. Desta forma conseguimos notar a diferença em relação aos parâmetros <code>alpha</code>, <code>betha</code> e <code>gamma</code>.</p>
<pre class="hljs"><code><div>L = 256
a = 80
b = 170
</div></code></pre>
<p><em>Imagem Original</em></p>
<p><img src="./images/city.png" alt="imagem original" title="Imagem Original"></p>
<p><em>Imagem Transformação de Contraste com <code>alpha = 0.1, beta = 1 e gamma = 1</code></em></p>
<p><img src="./outputs_aux/contrast/contrast1.png" alt="imagem com maior realce no preto" title="Imagem alpha = 0.1, beta = 1 e gamma = 1"></p>
<p><em>Imagem Transformação de Contraste com <code>alpha = 1, beta = 3 e gamma = 1</code></em></p>
<p><img src="./outputs_aux/contrast/contrast2.png" alt="imagem com maior realce no branco" title="Imagem alpha = 1, beta = 3 e gamma = 1"></p>
<p><em>Imagem Transformação de Contraste com <code>alpha = 1, beta = 1 e gamma = 0.1</code></em></p>
<p><img src="./outputs_aux/contrast/contrast3.png" alt="imagem com menor realce no branco" title="Imagem alpha = 1, beta = 1 e gamma = 0.1"></p>
<h2 id="limita%C3%A7%C3%B5es">Limitações</h2>
<p>Os resultados obtidos neste trabalho se aplicam e se limitam às imagens quadradas, monocromáticas ou coloridas e no formato <code>.png</code> ou <code>.jpg</code>.</p>
<p>Isto se deve principalmente aos tipos de processamentos implementados e às limitações das bibliotecas utilizadas.</p>
<h2 id="bibliografia">Bibliografia</h2>
<ol>
<li>Documentação das bibliotecas usadas
<ul>
<li><a href="https://pillow.readthedocs.io/en/stable/">Pillow</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/">NumPy</a></li>
<li><a href="https://jupyter-notebook.readthedocs.io/en/stable/">Jupyter Notebook</a></li>
</ul>
</li>
<li><em>R.C. Gonzalez, R.E. Woods. Digital Image Processing. Prentice Hall, 2007</em>.</li>
<li>Material de aula fornecido pelo Professor</li>
</ol>

</body>
</html>
